/** *  * Copyright (c) 2010, Michael Creighton * All rights reserved. *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice, *       this list of conditions and the following disclaimer. *  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution. *  *     * Neither the name of the organization nor the names of its * 	  contributors may be used to endorse or promote products *       derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. *  */package com.mikecreighton.flow.tuio {	import it.h_umus.tuio.Tuio2DCurClient;	import it.h_umus.tuio.events.Tuio2DCurEvent;	import com.mikecreighton.flow.data.Config;	import com.mikecreighton.flow.data.StrokePoint;	import com.mikecreighton.flow.events.StrokeEvent;	import com.mikecreighton.flow.events.UpdateEvent;	import org.casalib.events.RemovableEventDispatcher;	import org.casalib.time.Interval;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	[Event(name="connect", type="flash.events.Event")]	[Event(name="close", type="flash.events.Event")]	[Event(name="add", type="com.mikecreighton.flow.events.StrokeEvent")]	[Event(name="move", type="com.mikecreighton.flow.events.StrokeEvent")]	[Event(name="remove", type="com.mikecreighton.flow.events.StrokeEvent")]	/**	 * TuioManager handles all TUIO server connectivity and	 * limits the number of points tracked to one.	 * 	 * @author Mike Creighton	 */	public class TuioManager extends RemovableEventDispatcher	{		private static const RECONNECT_INTERVAL : int = 4000;		private static var _instance : TuioManager;		private var _connected : Boolean;		private var _tuioClient : Tuio2DCurClient;		private var _reconnectTimer : Interval;		private var _strokeId : int;		private var _tuioCurId : int;		private var _currStrokePoint : StrokePoint;
		public function TuioManager(enforcer : SingletonEnforcer) 		{			super();			_tuioClient = null;			_tuioCurId = -1;			_strokeId = -1;			_connected = false;			_currStrokePoint = null;			_reconnectTimer = Interval.setTimeout(_attemptReconnection, RECONNECT_INTERVAL);						Config.getInstance().addEventListener(UpdateEvent.UPDATE, _onConfigUpdated, false, 0, true);		}		/**		 * @return singleton instance of TuioManager		 */		public static function getInstance() : TuioManager 		{			if (TuioManager._instance == null)				TuioManager._instance = new TuioManager(new SingletonEnforcer());			return TuioManager._instance;		}		/**		 * Callback when the configuration of the server is changed by the user		 * while the application is running.		 */		private function _onConfigUpdated(event : UpdateEvent) : void		{			_initialize();			dispatchEvent(new Event(Event.CLOSE, true));			connectToServer();		}		/**		 * Starts the handling of all TUIO input and manages connectivity.		 */		private function _initialize() : void 		{			if(_tuioClient != null)			{				// Need to try to destroy our client.				_tuioClient.destroy();				_tuioClient = null;			}						_currStrokePoint = null;			_connected = false;			_tuioCurId = -1;						_tuioClient = new Tuio2DCurClient(Config.getInstance().server, Config.getInstance().port);			_tuioClient.addEventListener(Event.CONNECT, _onClientConnect, false, 0, true);			_tuioClient.addEventListener(Event.CLOSE, _onClientClose, false, 0, true);			_tuioClient.addEventListener(IOErrorEvent.IO_ERROR, _onClientIOError, false, 0, true);			_tuioClient.addEventListener(SecurityErrorEvent.SECURITY_ERROR, _onClientSecurityError, false, 0, true);			_tuioClient.addEventListener(Tuio2DCurEvent.ADD_TUIO_2D_CUR, _onAddCursor, false, 0, true);			_tuioClient.addEventListener(Tuio2DCurEvent.REMOVE_TUIO_2D_CUR, _onRemoveCursor, false, 0, true);			_tuioClient.addEventListener(Tuio2DCurEvent.UPDATE_TUIO_2D_CUR, _onUpdateCursor, false, 0, true);		}		private function _onAddCursor(event : Tuio2DCurEvent) : void 		{			if(_tuioCurId == -1)			{				_tuioCurId = event.data.s;				_strokeId++;				var e : StrokeEvent = new StrokeEvent(StrokeEvent.ADD, true);				_currStrokePoint = new StrokePoint(event.data.x, event.data.y, _strokeId);				e.strokePoint = _currStrokePoint;				dispatchEvent(e);
			}		}
		private function _onRemoveCursor(event : Tuio2DCurEvent) : void 		{			if(_tuioCurId > -1)			{				if(event.data.s == _tuioCurId)				{					_tuioCurId = -1;					var e : StrokeEvent = new StrokeEvent(StrokeEvent.REMOVE, true);					var p : StrokePoint = new StrokePoint(event.data.x, event.data.y, _strokeId);					e.strokePoint = p;					_currStrokePoint = null;					dispatchEvent(e);
				}			}		}
		private function _onUpdateCursor(event : Tuio2DCurEvent) : void 		{			if(_tuioCurId > -1)			{				if(event.data.s == _tuioCurId)				{					var e : StrokeEvent = new StrokeEvent(StrokeEvent.MOVE, true);					_currStrokePoint.x = event.data.x;					_currStrokePoint.y = event.data.y;					_currStrokePoint.id = _strokeId;					e.strokePoint = _currStrokePoint;					dispatchEvent(e);
				}			}		}		public function get currentStrokePoint() : StrokePoint		{			if(_currStrokePoint != null)				return _currStrokePoint.clone();			else				return null;		}
		/**		 * Main method for kicking off connection to a TUIO server.		 */		public function connectToServer() : void		{			if(_tuioClient == null)			{				_initialize();			}						if(!_connected)			{				_tuioCurId = -1;				_currStrokePoint = null;				_reconnectTimer.reset();				_reconnectTimer.stop();				_tuioClient.connect();			}		}		public function disconnectFromServer() : void		{			if(_connected && _tuioClient != null)			{				_tuioCurId = -1;				_currStrokePoint = null;				_reconnectTimer.reset();				_reconnectTimer.stop();				_tuioClient.disconnect();				dispatchEvent(new Event(Event.CLOSE, true));			}		}		/**		 * Event callback when we successfully connect to the TUIO TCP server.		 */		private function _onClientConnect(event : Event) : void 		{			// Stop any attempts at reconnections			_reconnectTimer.reset();			_reconnectTimer.stop();			_connected = true;			dispatchEvent(new Event(Event.CONNECT, true));
		}
		/**		 * Event callback when the server closes connection for some reason.		 */		private function _onClientClose(event : Event) : void 		{			_connected = false;			_tuioCurId = -1;			_currStrokePoint = null;			// Try to reconnect in a bit.			_reconnectTimer.reset();			_reconnectTimer.start();			dispatchEvent(new Event(Event.CLOSE, true));
		}
		private function _onClientIOError(event : IOErrorEvent) : void 		{			_tuioClient.disconnect();			_connected = false;			// Try to reconnect in a bit.			_reconnectTimer.reset();			_reconnectTimer.start();
		}
		private function _onClientSecurityError(event : SecurityErrorEvent) : void 		{			_connected = false;			// Try to reconnect in a bit.			_reconnectTimer.reset();			_reconnectTimer.start();
		}		private function _attemptReconnection() : void		{			_reconnectTimer.reset();			_reconnectTimer.stop();			_tuioClient.connect();		}		public function get connected() : Boolean		{			return _connected;		}
	}}class SingletonEnforcer{}